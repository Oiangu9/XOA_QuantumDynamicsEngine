#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

using namespace std;

int main(int argc, char **argv){
    if (argc<11){
        cout << "Error while reading the arguments. Too few arguments introduced? \n";
        return -1;
    }
    ofstream writtenFile;
    double option;
    sscanf(argv[10], "%lf", &option);
    if(option==1 || option==1.5){
        
    writtenFile.open("CODE_simulator_1D_CN_ABC_tINDEP.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    
    writtenFile << "//SCHRODINGER EQUATION SOLVER 1D - CRANCK NICOLSON METHOD with Absorbing Boundary Conditions (ABCs)\n// FOR TIME INDEPENDENT POTENTIALS!!!!\n// Implementation done following the notation and procedure suggested in the paper:\n// https://physik.uni-graz.at/~pep/Theses/BachelorThesis_Wachter_2017.pdf\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <eigen3/unsupported/Eigen/Splines>\n#include <random>\n#include <cmath>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\nconst double EULER=2.718281828459045;\n\ndouble hbar =" <<argv[8]<< ";\ndouble m=" <<argv[8]<< ";\n// We define the time intervals\n//double tmin = 0.0;\ndouble dt = " << argv[6]<<";\nint numIt = " << argv[7]<<";\n// We define the parameters for the x GRID\ndouble xmin = " << argv[4]<<" ;\ndouble xmax = " << argv[5]<<";\nint nx = " << argv[3] << ";\ndouble dx = (xmax-xmin)/nx;\n//---EXTRA OUTSIDE-MAIN CODE---\n"<< argv[11] << "\n//----\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psiO(double x){\n "<<argv[1] << ";\n}\n//We define the Potential Energy Field\ndouble V(double x){\n " << argv[2] << ";\n}\nint main(){\n// We build the the initial WavePacket\nVectorXcd psi_ini(nx+1);\nfor(int i=0; i<=nx;i++){\npsi_ini(i)=psiO(xmin+i*dx);\n} //there will be nx+1 points in the position axis\n\n//---EXTRA IN-MAIN CODE---\n"<< argv[12] << "\n//----\n// We generate the two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble> U1(nx+1, nx+1);\nU1.reserve(VectorXi::Constant(nx+1,3));\ncdouble a=J*dt*hbar/(4*m*dx*dx);\nfor(int i=1;i<nx;i++){\nU1.insert(i,i)= 1.0+J*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx))/((cdouble)2*hbar);\nU1.insert(i,i+1)= -a;\nU1.insert(i,i-1)= -a;\n}\n//for implementing the ABC-s\ndouble q1 = hbar*2.0/m; //we define the group velocities to be absorbed in the ABCs were q=hbar*k/m !!!!!SET IT 2*K0 if u want absorbing with k0>0 and SET it -2*k0 if k0<0\ndouble q2 = q1; // then the wavenumer k0 will be absorbed to second order\ndouble r1 = 2.0/(q1+q2); //parameters to make it easier the boundary implementation of U1 and U2 matrixes\ndouble r2 = q1*q2/(2*(q1+q2));\nU1.insert(0,0)= -J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin)-r2)/4.0;\nU1.insert(0,1)= J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin)-r2)/4.0;\nU1.insert(nx,nx)= -J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin)-r2)/4.0;\nU1.insert(nx,nx-1)= J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin)-r2)/4.0;\nU1.makeCompressed();\n//due to the ABS now U2 is not exactly equal to the complex conjugate of U1, but almost, just need the fix in the boundary of the grid\nSparseMatrix<cdouble> U2(nx+1, nx+1);\nU2.reserve(VectorXi::Constant(nx+1,3));\nU2 = U1.conjugate();\nU2.coeffRef(0,0)= J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin)-r2)/4.0;\nU2.coeffRef(0,1)= -J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin)-r2)/4.0;\nU2.coeffRef(nx,nx)= J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin)-r2)/4.0;\nU2.coeffRef(nx,nx-1)= -J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin)-r2)/4.0;\nU2.makeCompressed();\n// Make the LU decomposition of U1\nSparseLU<SparseMatrix<cdouble>> LUsolver;\nLUsolver.compute(U1);\nif(LUsolver.info()!=Success) {\ncout << \"LU decomposition FAILED!\" << endl;\nreturn 1;\n}\n//we prepare everything for the loop\nVectorXcd U2psi(nx+1), psiNext(nx+1);\npsiNext = psi_ini;\nofstream outsideFile;\noutsideFile.open(\"DATA_rawSimulationData_1D_CN.txt\");\n//outsideFile << \"CN 1D ABCs dx= \"<<dx<<\" xmin= \"<<xmin<<\" xmax= \"<<xmax<<\" dt= \"<<dt<<\" ItNum= \"<<numIt<<\" t0= \"<<tmin<<endl<<\"it0\"<<endl<<psi_ini<<endl;\noutsideFile << nx << \" \" << numIt << \" \" << dt << \" \" << xmin << \" \" << xmax << \" \" << m << \" \" << hbar << \" (Spatial divisions, time iterations, xmin, xmax, mass, hbar) CN 1D ABCs\" << endl;\noutsideFile << std::setprecision(17);\nfor(int it=1; it<=numIt; it++){\nU2psi= U2*psiNext;\npsiNext = LUsolver.solve(U2psi);\noutsideFile << \"it\"<<it<<endl<< psiNext<<endl;\n}\noutsideFile.close();//we also output the potential shape in a separate file as it is just one time instance\nofstream potentialFile;\ndouble auxX;\npotentialFile.open(\"DATA_potentialData_1D_CN.txt\");\nfor(int i=0; i<=nx; ++i){\nauxX=xmin+i*dx;\npotentialFile << auxX << \" \" << V(auxX) <<endl;\n}\npotentialFile.close();\nreturn 0;\n}\n";
    
    
    
    writtenFile.close();
    return 0;
    
    } else if(option==2){
        
    writtenFile.open("CODE_simulator_1D_CN_ABC_tDEP.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    
    writtenFile << "//SCHRODINGER EQUATION SOLVER 1D - CRANCK NICOLSON METHOD with Absorbing Boundary Conditions (ABCs)\n// FOR TIME DEPENDENT POTENTIALS!!!!\n// Implementation done following the notation and procedure suggested in the paper:\n// https://physik.uni-graz.at/~pep/Theses/BachelorThesis_Wachter_2017.pdf\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <cmath>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\nconst double EULER=2.718281828459045;\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psiO(double x){\n " << argv[1] << ";\n}\ndouble hbar =" <<argv[8]<< ";\ndouble m=" <<argv[8]<< ";\n//We define the Potential Energy Field in time\ndouble V(double x, double t){\n " << argv[2] << ";\n}\nint main(){\n// We define the time intervals\ndouble tmin = 0.0;\ndouble dt = " << argv[6]<<";\nint numIt = " << argv[7]<<";\n// We define the parameters for the x GRID\ndouble xmin = " << argv[4]<<" ;\ndouble xmax = " << argv[5]<<";\nint nx = " << argv[3] << ";\ndouble dx = (xmax-xmin)/nx;\n// We build the the initial WavePacket\nVectorXcd psi_ini(nx+1);\nfor(int i=0; i<=nx;i++){\npsi_ini(i)=psiO(xmin+i*dx);\n} //there will be nx+1 points in the position axis\n// We build the templates for two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble> U1(nx+1, nx+1);\nU1.reserve(VectorXi::Constant(nx+1,3));\ncdouble a=J*dt*hbar/(4*m*dx*dx);\nfor(int i=1;i<nx;i++){\nU1.insert(i,i)= 1.0+J*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx,tmin))/((cdouble)2*hbar);\nU1.insert(i,i+1)= -a;\nU1.insert(i,i-1)= -a;\n}\n//for implementing the ABC-s\ndouble q1 = hbar*2.0/m; //we define the group velocities to be absorbed in the ABCs were q=hbar*k/m !!!!!SET IT 2*K0 if u want absorbing with k0>0 and SET it -2*k0 if k0<0\ndouble q2 = q1; // then the wavenumer k0 will be absorbed to second order\ndouble r1 = 2.0/(q1+q2); //parameters to make it easier the boundary implementation of U1 and U2 matrixes\ndouble r2 = q1*q2/(2*(q1+q2));\nU1.insert(0,0)= -J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin)-r2)/4.0;\nU1.insert(0,1)= J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin)-r2)/4.0;\nU1.insert(nx,nx)= -J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin)-r2)/4.0;\nU1.insert(nx,nx-1)= J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin)-r2)/4.0;\nU1.makeCompressed();\n//due to the ABS now U2 is not exactly equal to the complex conjugate of U1, but almost, just need the fix in the boundary of the grid\nSparseMatrix<cdouble> U2(nx+1, nx+1);\nU2.reserve(VectorXi::Constant(nx+1,3));\nU2 = U1.conjugate();\nU2.makeCompressed();\n// Make the LU decomposition of U1\nSparseLU<SparseMatrix<cdouble>> LUsolver;\nLUsolver.compute(U1);\nif(LUsolver.info()!=Success) {\ncout << \"LU decomposition FAILED!\" << endl;\nreturn 1;\n}\n//we prepare everything for the loop\nVectorXcd U2psi(nx+1), psiNext(nx+1);\npsiNext = psi_ini;\nofstream outsideFile;\noutsideFile.open(\"DATA_rawSimulationData_1D_CN.txt\");\n//outsideFile << \"CN 1D ABCs dx= \"<<dx<<\" xmin= \"<<xmin<<\" xmax= \"<<xmax<<\" dt= \"<<dt<<\" ItNum= \"<<numIt<<\" t0= \"<<tmin<<endl<<\"it0\"<<endl<<psi_ini<<endl;\noutsideFile << nx << \" \" << numIt << \" \" << dt << \" \" << xmin << \" \" << xmax << \" \" << m << \" \" << hbar << \" (Spatial divisions, time iterations, time step, xmin, xmax, mass, hbar) CN 1D ABCs\" << endl;\noutsideFile << std::setprecision(17);\nfor(int it=1; it<=numIt; it++){\n//we redefine the propagator matrices for the new time (the potential is time dependent)\nfor(int i=1;i<nx;i++){\nU1.coeffRef(i,i)= 1.0+J*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx,tmin+dt*it))/((cdouble)2*hbar);\n}\nU1.coeffRef(0,0)= -J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU1.coeffRef(0,1)= J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU1.coeffRef(nx,nx)= -J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU1.coeffRef(nx,nx-1)= J/(2*dx)-J*r1/(2*dt)+(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU1.makeCompressed();\nU2 = U1.conjugate();\nU2.coeffRef(0,0)= J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU2.coeffRef(0,1)= -J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU2.coeffRef(nx,nx)= J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU2.coeffRef(nx,nx-1)= -J/(2*dx)-J*r1/(2*dt)-(r1*V(xmin,tmin+dt*it)-r2)/4.0;\nU2.makeCompressed();\nLUsolver.compute(U1);\nif(LUsolver.info()!=Success) {\ncout << \"LU decomposition FAILED!\" << endl;\nreturn 1;\n}\nU2psi= U2*psiNext;\npsiNext = LUsolver.solve(U2psi);\noutsideFile << \"it\"<<it<<endl<< psiNext<<endl;\n}\noutsideFile.close();\nreturn 0;\n}\n";
    
    
    
    writtenFile.close();
    return 0;
        
    }  else if(option==9){
        
    writtenFile.open("CODE_simulator_1D_CN_tINDEP_ImTimeEv.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    writtenFile << "//SCHRODINGER EQUATION IMAGINARY TIME EVOLUTION SOLVER 1D - CRANCK NICOLSON METHOD NO ABCs\n// FOR TIME INDEPENDENT POTENTIALS!!!!\n// Implementation done following the notation and procedure suggested in the paper:\n// https://physik.uni-graz.at/~pep/Theses/BachelorThesis_Wachter_2017.pdf\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <eigen3/unsupported/Eigen/Splines>\n#include <random>\n#include <cmath>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\nconst double EULER=2.718281828459045;\n\ndouble hbar =" <<argv[8]<< ";\ndouble m=" <<argv[8]<< ";\n// We define the time intervals\n//double tmin = 0.0;\ndouble dt = " << argv[6]<<";\nint numIt = " << argv[7]<<";\n// We define the parameters for the x GRID\ndouble xmin = " << argv[4]<<" ;\ndouble xmax = " << argv[5]<<";\nint nx = " << argv[3] << ";\ndouble dx = (xmax-xmin)/nx;\n//We define the substitute for complex i in the Schrodinger Equation\ncdouble substituteFor_i = "<< argv[13] << ";\n//---EXTRA OUTSIDE-MAIN CODE---\n"<< argv[11] << "\n//----\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psiO(double x){\n "<<argv[1] << ";\n}\n//We define the Potential Energy Field\ndouble V(double x){\n " << argv[2] << ";\n}\nint main(){\n// We build the the initial WavePacket\nVectorXcd psi_ini(nx+1);\nfor(int i=0; i<=nx;i++){\npsi_ini(i)=psiO(xmin+i*dx);\n} //there will be nx+1 points in the position axis\n\n//---EXTRA IN-MAIN CODE---\n"<< argv[12] << "\n//----\n// We generate the two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble> U1(nx+1, nx+1);\nU1.reserve(VectorXi::Constant(nx+1,3));\ncdouble a=substituteFor_i*dt*hbar/(4*m*dx*dx);\nfor(int i=1;i<nx;i++){\nU1.insert(i,i)= 1.0+substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx))/((cdouble)2*hbar);\nU1.insert(i,i+1)= -a;\nU1.insert(i,i-1)= -a;\n}\nU1.insert(0,0)= 1.0+substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmin))/((cdouble)2*hbar);\nU1.insert(0,1)=-a;\nU1.insert(nx,nx)= 1.0+substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmax))/((cdouble)2*hbar);\nU1.insert(nx,nx-1)= -a;\nU1.makeCompressed();\n//U2 is exactly equal to the complex conjugate of U1 IF we dont substitute i for a real number, else, we should include the signs manually\nSparseMatrix<cdouble> U2(nx+1, nx+1);\nU2.reserve(VectorXi::Constant(nx+1,3));\nfor(int i=1;i<nx;i++){\nU2.insert(i,i)= 1.0-substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx))/((cdouble)2*hbar);\nU2.insert(i,i+1)= a;\nU2.insert(i,i-1)= a;\n}\nU2.insert(0,0)= 1.0-substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmin))/((cdouble)2*hbar);\nU2.insert(0,1)=a;\nU2.insert(nx,nx)= 1.0-substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmax))/((cdouble)2*hbar);\nU2.insert(nx,nx-1)= a;\nU2.makeCompressed();\n//we declare the probabDensity vector for the norm calculation\n ArrayXd probDensity(nx+1);\n double normSqrd;\n// Make the LU decomposition of U1\nSparseLU<SparseMatrix<cdouble>> LUsolver;\nLUsolver.compute(U1);\nif(LUsolver.info()!=Success) {\ncout << \"LU decomposition FAILED!\" << endl;\nreturn 1;\n}\n//we prepare everything for the loop\nVectorXcd U2psi(nx+1), psiNext(nx+1);\npsiNext = psi_ini;\nofstream outsideFile;\noutsideFile.open(\"DATA_rawSimulationData_1D_CN.txt\");\n//outsideFile << \"CN 1D ABCs dx= \"<<dx<<\" xmin= \"<<xmin<<\" xmax= \"<<xmax<<\" dt= \"<<dt<<\" ItNum= \"<<numIt<<\" t0= \"<<tmin<<endl<<\"it0\"<<endl<<psi_ini<<endl;\noutsideFile << nx << \" \" << numIt << \" \" << dt << \" \" << xmin << \" \" << xmax << \" \" << m << \" \" << hbar << \" (Spatial divisions, time iterations, xmin, xmax, mass, hbar) CN 1D ABCs\" << endl;\noutsideFile << std::setprecision(17);\nfor(int it=1; it<=numIt; it++){\nU2psi= U2*psiNext;\npsiNext = LUsolver.solve(U2psi);\n//the waveFunction is re-normalised after each imaginary dissipative time\n//well first calculate the squared norm of the wavevector and then divide it by the sqrt of it\nprobDensity = abs2(psiNext.array());\nnormSqrd=0.5*(probDensity(0) + probDensity(nx));\n for(int ix=0; ix<=nx; ++ix){normSqrd+=probDensity(ix);}\nnormSqrd*=dx;\npsiNext = psiNext/sqrt(normSqrd); \noutsideFile << \"it\"<<it<<endl<< psiNext<<endl;\n}\noutsideFile.close();//we also output the potential shape in a separate file as it is just one time instance\nofstream potentialFile;\ndouble auxX;\npotentialFile.open(\"DATA_potentialData_1D_CN.txt\");\nfor(int i=0; i<=nx; ++i){\nauxX=xmin+i*dx;\npotentialFile << auxX << \" \" << V(auxX) <<endl;\n}\npotentialFile.close();\nreturn 0;\n}\n";
    
    /*
// We generate the two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble> U1(nx+1, nx+1);\nU1.reserve(VectorXi::Constant(nx+1,3));\ncdouble a=substituteFor_i*dt*hbar/(4*m*dx*dx);\nfor(int i=1;i<nx;i++){\nU1.insert(i,i)= 1.0+substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx))/((cdouble)2*hbar);\nU1.insert(i,i+1)= -a;\nU1.insert(i,i-1)= -a;\n}\nU1.insert(0,0)= 1.0+substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmin))/((cdouble)2*hbar);\nU1.insert(0,1)=-a;\nU1.insert(nx,nx)= 1.0+substituteFor_i*dt*(hbar*hbar/(m*dx*dx)+V(xmax))/((cdouble)2*hbar);\nU1.insert(nx,nx-1)= -a;\nU1.makeCompressed();\n//U2 is exactly equal to the complex conjugate of U1\nSparseMatrix<cdouble> U2(nx+1, nx+1);\nU2.reserve(VectorXi::Constant(nx+1,3));\nU2 = U1.conjugate();\nU2.makeCompressed();\n// Prepare the Propagator Operator of the wave function//\nMatrixXcd U1_invU2(nx+1,nx+1);\nU1_invU2 = MatrixXcd(U1);\nU1_invU2=U1_invU2.inverse();\nU1_invU2=U1_invU2*U2;\n//we prepare everything for the loop\nVectorXcd psiNext(nx+1);\npsiNext = psi_ini;\nofstream outsideFile;\noutsideFile.open(\"DATA_rawSimulationData_1D_CN.txt\");\n//outsideFile << \"CN 1D ABCs dx= \"<<dx<<\" xmin= \"<<xmin<<\" xmax= \"<<xmax<<\" dt= \"<<dt<<\" ItNum= \"<<numIt<<\" t0= \"<<tmin<<endl<<\"it0\"<<endl<<psi_ini<<endl;\noutsideFile << nx << \" \" << numIt << \" \" << dt << \" \" << xmin << \" \" << xmax << \" \" << m << \" \" << hbar << \" (Spatial divisions, time iterations, xmin, xmax, mass, hbar) CN 1D ABCs\" << endl;\noutsideFile << std::setprecision(17);\nfor(int it=1; it<=numIt; it++){\npsiNext = U1_invU2 * psiNext;\noutsideFile << \"it\"<<it<<endl<< psiNext<<endl;\n
     */
    
    
    writtenFile.close();
    return 0;
    
    } else if(option==9.5){
        
    writtenFile.open("CODE_simulator_1D_CN_tDEP_ImTimeEv.cpp");
    if(!writtenFile.good()){
        cout << "Error while creating the code files!\n";
        return 1;
    }
    writtenFile << "//SCHRODINGER EQUATION SOLVER IMAGINARY TIME EVOLUTION 1D - CRANCK NICOLSON METHOD with NO ABCs\n// FOR TIME DEPENDENT POTENTIALS!!!!\n// Implementation done following the notation and procedure suggested in the paper:\n// https://physik.uni-graz.at/~pep/Theses/BachelorThesis_Wachter_2017.pdf\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <complex>\n#include \"LIB_dcomplex.h\" // Macro for using dcomplex as std::complex<double> and J as the complex 0.0+i*1.0\n#include <eigen3/Eigen/Core>\n#include <eigen3/Eigen/Sparse>\n#include <eigen3/Eigen/SparseLU>\n#include <cmath>\nusing namespace std::complex_literals;\nusing namespace Eigen;\nusing namespace std;\nconst double PI = 3.141592653589793238463;\nconst double EULER=2.718281828459045;\n// We DEFINE the INITIAL WAVEPACKET\ncdouble psiO(double x){\n " << argv[1] << ";\n}\ndouble hbar =" <<argv[8]<< ";\ndouble m=" <<argv[8]<< ";\n// We define the time intervals\ndouble tmin = 0.0;\ndouble dt = " << argv[6]<<";\nint numIt = " << argv[7]<<";\n// We define the parameters for the x GRID\ndouble xmin = " << argv[4]<<" ;\ndouble xmax = " << argv[5]<<";\nint nx = " << argv[3] << ";\ndouble dx = (xmax-xmin)/nx;\n//We set the time dependant susbtitute for i for the imaginary time evolution\ncdouble substituteFor_i(double t){" <<argv[13]<< ";}\n//We define the Potential Energy Field in time\ndouble V(double x, double t){\n " << argv[2] << ";\n}\nint main(){\n// We build the the initial WavePacket\nVectorXcd psi_ini(nx+1);\nfor(int i=0; i<=nx;i++){\npsi_ini(i)=psiO(xmin+i*dx);\n} //there will be nx+1 points in the position axis\n// We build the templates for two matrix operators that compose the unitary aproximation of the PROPAGATOR operator\nSparseMatrix<cdouble> U1(nx+1, nx+1);\nU1.reserve(VectorXi::Constant(nx+1,3));\nSparseMatrix<cdouble> U2(nx+1, nx+1);\nU2.reserve(VectorXi::Constant(nx+1,3));\ncdouble a=substituteFor_i(tmin)*dt*hbar/(4*m*dx*dx);\nfor(int i=1;i<nx;i++){\nU1.insert(i,i)= 1.0+substituteFor_i(tmin)*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx,tmin))/((cdouble)2*hbar);\nU1.insert(i,i+1)= -a;\nU1.insert(i,i-1)= -a;\nU2.insert(i,i)= 1.0-substituteFor_i(tmin)*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx,tmin))/((cdouble)2*hbar);\nU2.insert(i,i+1)= a;\nU2.insert(i,i-1)= a;\n}\n\nU1.insert(0,0)=  1.0+substituteFor_i(tmin)*dt*(hbar*hbar/(m*dx*dx)+V(xmin,tmin))/((cdouble)2*hbar);\nU1.insert(0,1)=-a;\nU1.insert(nx,nx)=  1.0+substituteFor_i(tmin)*dt*(hbar*hbar/(m*dx*dx)+V(xmax,tmin))/((cdouble)2*hbar);\nU1.insert(nx,nx-1)= -a;\nU1.makeCompressed();\nU2.insert(0,0)=  1.0-substituteFor_i(tmin)*dt*(hbar*hbar/(m*dx*dx)+V(xmin,tmin))/((cdouble)2*hbar);\nU2.insert(0,1)=a;\nU2.insert(nx,nx)=  1.0-substituteFor_i(tmin)*dt*(hbar*hbar/(m*dx*dx)+V(xmax,tmin))/((cdouble)2*hbar);\nU2.insert(nx,nx-1)= a;\n\nU2.makeCompressed();\n//we declare the probabDensity vector for the norm calculation\n ArrayXd probDensity(nx+1);\n double normSqrd;\nU2.makeCompressed();\n// Make the LU decomposition of U1\nSparseLU<SparseMatrix<cdouble>> LUsolver;\nLUsolver.compute(U1);\nif(LUsolver.info()!=Success) {\ncout << \"LU decomposition FAILED!\" << endl;\nreturn 1;\n}\n//we prepare everything for the loop\nVectorXcd U2psi(nx+1), psiNext(nx+1);\npsiNext = psi_ini;\nofstream outsideFile;\noutsideFile.open(\"DATA_rawSimulationData_1D_CN.txt\");\n//outsideFile << \"CN 1D ABCs dx= \"<<dx<<\" xmin= \"<<xmin<<\" xmax= \"<<xmax<<\" dt= \"<<dt<<\" ItNum= \"<<numIt<<\" t0= \"<<tmin<<endl<<\"it0\"<<endl<<psi_ini<<endl;\noutsideFile << nx << \" \" << numIt << \" \" << dt << \" \" << xmin << \" \" << xmax << \" \" << m << \" \" << hbar << \" (Spatial divisions, time iterations, time step, xmin, xmax, mass, hbar) CN 1D ABCs\" << endl;\noutsideFile << std::setprecision(17);\nfor(int it=1; it<=numIt; it++){\n//we redefine the propagator matrices for the new time (the potential is time dependent)\na=substituteFor_i(tmin+it*dt)*dt*hbar/(4*m*dx*dx);\nfor(int i=1;i<nx;i++){\nU1.coeffRef(i,i)= 1.0+substituteFor_i(tmin+it*dt)*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx,tmin+it*dt))/((cdouble)2*hbar);\nU1.coeffRef(i,i+1)= -a;\nU1.coeffRef(i,i-1)= -a;\nU2.coeffRef(i,i)= 1.0-substituteFor_i(tmin+it*dt)*dt*(hbar*hbar/(m*dx*dx)+V(xmin+i*dx,tmin+it*dt))/((cdouble)2*hbar);\nU2.coeffRef(i,i+1)= a;\nU2.coeffRef(i,i-1)= a;\n}\n\nU1.coeffRef(0,0)=  1.0+substituteFor_i(tmin+it*dt)*dt*(hbar*hbar/(m*dx*dx)+V(xmin,tmin+it*dt))/((cdouble)2*hbar);\nU1.coeffRef(0,1)=-a;\nU1.coeffRef(nx,nx)=  1.0+substituteFor_i(tmin+it*dt)*dt*(hbar*hbar/(m*dx*dx)+V(xmax,tmin+it*dt))/((cdouble)2*hbar);\nU1.coeffRef(nx,nx-1)= -a;\nU1.makeCompressed();\nU2.coeffRef(0,0)=  1.0-substituteFor_i(tmin+it*dt)*dt*(hbar*hbar/(m*dx*dx)+V(xmin,tmin+it*dt))/((cdouble)2*hbar);\nU2.coeffRef(0,1)=a;\nU2.coeffRef(nx,nx)=  1.0-substituteFor_i(tmin+it*dt)*dt*(hbar*hbar/(m*dx*dx)+V(xmax,tmin+it*dt))/((cdouble)2*hbar);\nU2.coeffRef(nx,nx-1)= a;\n\nU2.makeCompressed();\n\nLUsolver.compute(U1);\nif(LUsolver.info()!=Success) {\ncout << \"LU decomposition FAILED!\" << endl;\nreturn 1;\n}\nU2psi= U2*psiNext;\npsiNext = LUsolver.solve(U2psi);\n//the waveFunction is re-normalised after each imaginary dissipative time\n//well first calculate the squared norm of the wavevector and then divide it by the sqrt of it\nprobDensity = abs2(psiNext.array());\nnormSqrd=0.5*(probDensity(0) + probDensity(nx));\n for(int ix=0; ix<=nx; ++ix){normSqrd+=probDensity(ix);}\nnormSqrd*=dx;\npsiNext = psiNext/sqrt(normSqrd); \noutsideFile << \"it\"<<it<<endl<< psiNext<<endl;\n}\noutsideFile.close();\nreturn 0;\n}\n";
   
    writtenFile.close();
    return 0;
    
    }
}
